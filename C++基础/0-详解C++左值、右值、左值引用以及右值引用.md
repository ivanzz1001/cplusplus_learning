# 详解 C++ 左值、右值、左值引用以及右值引用

参看:

- [详解 C++ 左值、右值、左值引用以及右值引用](https://www.cnblogs.com/david-china/p/17080072.html)

## 1. 左值和右值

### 1.1 左值

左值是一个表示数据的表达式，比如：变量名、解引用的指针变量。一般地，我们可以获取它的地址和对它赋值，但被`const`修饰后的左值，不能给它赋值，但是仍然可以取它的地址。总体而言，**可以取地址的对象就是左值**。

```c
//以下的a, p, *p, b都是左值
int a = 3;
int *p = &a;
*p;
const int b = 2;
```

### 1.2 右值

右值也是一个表示数据的表达式，比如：字面常量、表达式返回值，传值返回函数的返回值（是传值返回，而非传引用返回），右值不能出现在赋值符号的左边且不能取地址。总体而言，**不可以取地址的对象就是右值**。

```c
double x = 1.3, y = 3.8;

//以下几个都是常见的右值
10;                        //字面常量
x + y;                     //表达式返回值
fmin(x, y);                //传值返回函数的返回值
```

以下写法均不能通过编译:
```c
10 = 4; x + y = 4; fmin(x, y) = 4;    //gcc编译报错: lvalue required as left operand of assignment

&10; &(x+y); &fmin(x, y);             //gcc编译报错: lvalue required as unary ‘&’ operand
```
### 1.3 总结

区分左值和右值，终究还是要看能否取地址。


## 2. 左值引用和右值引用

传统的 C++ 语法中就存在引用语法，而C++11标准中新增了右值引用的语法特性，因此为了区分两者，将C++11标准出现之前的引用称为左值引用。

`无论左值引用还是右值引用，都是给对象取别名`.

### 2.1 左值引用

左值引用就是对左值的引用，给左值取别名。**主要作用是避免对象拷贝**

```c
//以下几个是对上面左值的引用
int& ra = a;
int*& rp = p;
int& r = *p;
const int& rb = b;
```

### 2.2 右值引用
右值引用就是对右值的引用，给右值取别名。**主要作用是把延长对象的生命周期，一般是延长到作用域的scope之外**

右值引用的表示是在具体的变量类型名称后加两个`&`， 例如: `int&& r = 4;`

```c
//以下几个是对上面右值的右值引用
int&& rr1 = 10;
double&& rr2 = x + y;
double&& rr3 = fmin(x, y);
```

1. `注意`
  
  - 右值引用引用右值，会使右值被存储到特定的位置。

  - 也就是说：右值引用变量其实是左值，可以对它取地址和赋值(const右值引用变量可以取地址但不可以赋值，因为 const 在起作用)。

  - 当然，取地址是指取变量空间的地址（右值是不能取地址的）。

  - 示例
    ```c
    // 右值引用 rr2 引用右值 x + y 后，该表达式的返回值被存储到特定的位置，
    // 不能取表达式返回值 x + y 的地址，但是可以取 rr2 的地址，也可以修改 rr2
    double&& rr2 = x + y;
    &rr2;
    rr2 = 9.4;

    // 可以对 rr4 取地址，但不能修改 rr4，即写成rr4 = 5.3;会编译报错
    const double&& rr4 = x + y;
    &rr4;
    ```

现在我们知道左值引用可以引用左值，右值引用可以引用右值。

那么，左值引用是否可以引用右值？右值引用是否可以引用左值呢？

- 左值引用可以指向右值，但需要const来修饰，不能修改这个值

- 右值引用可以指向左值，需要std::move(v)即可

- 声明出来的左值引用或右值引用都是左值

下面的对比与总结给出详细探讨解释。

### 2.3 对比总结

#### 2.3.1 左值引用总结

- 左值引用只能引用左值，不能直接引用右值。

- 但是const左值引用既可以引用左值，也可以引用右值

```c
// 1.左值引用只能引用左值
int t = 8;
int& rt1 = t;
//int& rt2 = 8;          // 编译报错，因为8是右值，不能直接引用右值

// 2.但是const左值引用既可以引用左值
const int& rt3 = t;
const int& rt4 = 8;      // 也可以引用右值 const int& rt4本质上也是一个常量，指向一个不能被修改的右值，也是安全的
const double& r1 = x + y;
const double& r2 = fmin(x, y);
```

1. `为什么const左值引用也可以引用右值？`

    - 在 C++11标准产生之前，是没有右值引用这个概念的，当时如果想要一个类型既能接收左值也能接收右值的话，需要用const左值引用，比如标准容器的 push_back 接口：void push_back (const T& val)。

    - 也就是说，如果const左值引用不能引用右值的话，有些接口就不好支持了。

    - 另外，const左值引用，本意上是指向一个不被（该引用本身）它修改的内存区域，本质上这个引用变量本身也就是一个常量，至于这个内存区域对应一个全局变量、局部变量、xvalue，无所谓啊

2. `C++98标准中相关接口const左值引用引用右值的例子`

    ```c
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    ```

#### 2.3.2 右值引用总结

- 右值引用只能引用右值，不能直接引用左值。

- 但是右值引用可以引用被move的左值。
  
说明: 上面的move，本文指std::move（C++11），作用是将一个左值强制转化为右值，以实现移动语义。左值被 move 后变为右值，于是右值引用可以引用

```c
// 1.右值引用只能引用右值
int&& rr1 = 10;
double&& rr2 = x + y;
const double&& rr3 = x + y;

int t = 10;
//int&& rrt = t;                // 编译报错，不能直接引用左值

// 2.但是右值引用可以引用被move的左值
int&& rrt = std::move(t);
int*&& rr4 = std::move(p);
int&& rr5 = std::move(*p);
const int&& rr6 = std::move(b);
  ```

## 3. 左值引用的使用场景及实际意义

### 3.1 左值引用场景

左值引用主要是为了避免对象拷贝。下面我们介绍其使用场景。

#### 3.1.1 左值引用做参数

 当引用作为参数的时候，其效果跟利用指针作为参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或者对象的一个别名使用，也就是说函数中对形参的各种操作实际上就是对实参本身的操作，而非简单的实参变量或者对象的值拷贝给形参。

 ```c
void func1(string s)
{
    ...
}

void func2(const string& s)
{
    ...
}


int main(int argc, char *argv[])
{
    string s1("Hello World!");
    func1(s1);  // 由于是传值传参且做的是深拷贝，代价较大
    func2(s1);  // 左值引用做参数减少了拷贝，提高了效率    
    return 0;
}
 ```
说明:

 - 通常函数调用时采用值传递的方式，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，所以形参变量只是实参变量的副本而已，并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象    
 
 - 使用引用作为参数传递时，由于此时形参只是传递函数的实参变量或者对象的别名而非副本，故系统不会耗费时间在内存中开辟空间来存储形参，因此如果参数传递的数据较大，建议使用引用作为函数的形参，提高函数的时间效率，节省内存空间    
 
 - 指针作为函数的形参，虽然达到的效果跟使用引用一样，但当调用函数时仍然需要为形参指针分配空间，引用则不需要【引用在底层也会分配指针大小的空间，在汇编底层角度，引用和指针是一样的，不过引用类似于常量指针】。推荐使用引用而非指针作为函数的传递函数

#### 3.1.2 左值引用做返回值

左值引用做返回值时，仅限于对象出了函数作用域以后还存在的情况。
```c
string s2("hello");
// string operator+=(char ch)     // 传值返回存在拷贝且是深拷贝
// string& operator+=(char ch)    // 左值引用做返回值没有拷贝，提高了效率
s2 += '!';
```

### 3.2 实际意义

左值引用的实际意义: 减少拷贝，节省内存，提高效率。

传值传参和传值返回都会产生拷贝，有的甚至是深拷贝，代价很大。而左值引用的实际意义在于做参数和做返回值都可以减少拷贝，从而提高效率。

### 3.3 短板

左值引用短板：不能引用局部变量问题。

左值引用虽然较完美地解决了大部分问题，但对于有些问题仍然不能很好地解决。

1. `全局变量`

    当对象（全局变量）出了函数作用域以后仍然存在时，可以使用左值引用返回，这是没问题的。

    ```c
    string& operator+=(char ch)
    {
        push_back(ch);
        return *this;
    }
    ```

1. `局部变量`

    但当对象（对象是函数内的局部对象）出了函数作用域以后不存在时，就不可以使用左值引用返回了。

    ```c
    string operator+(const string& s, char ch)
    {
        string ret(s);
        ret.push_back(ch);
        return ret;
    }
    ```
    拿上面这个函数来举例：ret是函数内的局部对象，出了函数作用域后会被析构，即被销毁了。若此时再返回它的别名（左值引用），也就是再拿这个对象来用，就会出问题。

    ①：不能返回局部变量的引用。局部变量会在函数返回后被销毁，此时对 局部变量的引用就会成为“无所指”的引用，程序会进入未知状态。

    ②：不能返回函数内部通过 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，那么就可能造成这个引用所指向的空间（有 new 分配）无法释放的情况（由于没有具体的变量名，故无法用 delete 手动释放该内存），从而造成内存泄漏。

    于是，对于第二种情形，左值引用也无能为力，只能传值返回。

## 4. 右值引用

于是，为了解决上述传值返回的拷贝问题，C++11标准就增加了右值引用 和 移动语义。

### 4.1 移动语义（Move semantics）

将一个对象中的资源移动到另一个对象（资源控制权的转移）

#### 4.1.1 移动构造

1. `概念`

    转移参数右值的资源来构造自己。

    ```c
    // 这是一个模拟string类的实现的移动构造
    string(string&& s)
    :_str(nullptr)
    , _size(0)
    , _capacity(0)
   {
        swap(s);
   }
    ```
    拷贝构造函数和移动构造函数都是构造函数的重载函数，所不同的是：

      - 拷贝构造函数的参数是 const左值引用，接收左值或右值；
      - 移动构造函数的参数是右值引用，接收右值或被 move 的左值。

    >ps: 当传来的参数是右值时，虽然拷贝构造函数可以接收，但是编译器会认为移动构造函数更加匹配，就会调用移动构造函数。

    总的来说，如果这两个函数都有在类内定义的话，在构造对象时：

      - 若是左值做参数，那么就会调用拷贝构造函数，做一次拷贝（如果是像 string 这样的在堆空间上存在资源的类，那么每调用一次拷贝构造就会做一次深拷贝）。
      - 若是右值做参数，那么就会调用移动构造，而调用移动构造就会减少拷贝（如果是像 string 这样的在堆空间上存在资源的类，那么每调用一次移动构造就会少做一次深拷贝）

    比如执行下面这几行代码：
    ```c
    string s("Hello World11111111111111111");
    string s1 = s;        // s是左值，所以调用拷贝构造函数
    string s2 = move(s);  // s被move后变为右值，所以调用移动构造函数，s的资源会被转移用来构造s2
    
    // 要注意的是，move一般是不这样用的，因为s的资源被转走了  
    ```
    ![20250207-1001](https://raw.githubusercontent.com/ivanzz1001/cplusplus_learning/master/C%2B%2B%E5%9F%BA%E7%A1%80/image/20250207_1001.png)
   
   